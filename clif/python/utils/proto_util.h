//////////////////////////////////////////////////////////////////////
// This file was automatically generated by CLIF to run under Python 2
// Version 0.3
//////////////////////////////////////////////////////////////////////
// source: /workspace/clif_backend/llvm/llvm/tools/clif/python/utils/proto_util.clif

#include <memory>
#include "clif/python/optional.h"
#include "clif/python/proto_util.h"
#include "clif/python/postconv.h"

namespace clif_proto {
using namespace ::clif;

// CLIF use `::clif_proto::MethodInfo` as MethodInfo
bool Clif_PyObjAs(PyObject* input, ::clif_proto::MethodInfo** output);
bool Clif_PyObjAs(PyObject* input, std::shared_ptr<::clif_proto::MethodInfo>* output);
bool Clif_PyObjAs(PyObject* input, std::unique_ptr<::clif_proto::MethodInfo>* output);
bool Clif_PyObjAs(PyObject* input, ::clif_proto::MethodInfo* output);
bool Clif_PyObjAs(PyObject* input, ::gtl::optional<::clif_proto::MethodInfo>* output);
PyObject* Clif_PyObjFrom(::clif_proto::MethodInfo*, py::PostConv);
PyObject* Clif_PyObjFrom(std::shared_ptr<::clif_proto::MethodInfo>, py::PostConv);
PyObject* Clif_PyObjFrom(std::unique_ptr<::clif_proto::MethodInfo>, py::PostConv);
PyObject* Clif_PyObjFrom(const ::clif_proto::MethodInfo&, py::PostConv);
// CLIF use `::clif_proto::ProtoFileInfo` as ProtoFileInfo
bool Clif_PyObjAs(PyObject* input, ::clif_proto::ProtoFileInfo** output);
bool Clif_PyObjAs(PyObject* input, std::shared_ptr<::clif_proto::ProtoFileInfo>* output);
bool Clif_PyObjAs(PyObject* input, std::unique_ptr<::clif_proto::ProtoFileInfo>* output);
PyObject* Clif_PyObjFrom(::clif_proto::ProtoFileInfo*, py::PostConv);
PyObject* Clif_PyObjFrom(std::shared_ptr<::clif_proto::ProtoFileInfo>, py::PostConv);
PyObject* Clif_PyObjFrom(std::unique_ptr<::clif_proto::ProtoFileInfo>, py::PostConv);
PyObject* Clif_PyObjFrom(const ::clif_proto::ProtoFileInfo*, py::PostConv) = delete;
PyObject* Clif_PyObjFrom(const ::clif_proto::ProtoFileInfo&, py::PostConv) = delete;
// CLIF use `::clif_proto::ProtoTypeInfo` as ProtoTypeInfo
bool Clif_PyObjAs(PyObject* input, ::clif_proto::ProtoTypeInfo** output);
bool Clif_PyObjAs(PyObject* input, std::shared_ptr<::clif_proto::ProtoTypeInfo>* output);
bool Clif_PyObjAs(PyObject* input, std::unique_ptr<::clif_proto::ProtoTypeInfo>* output);
bool Clif_PyObjAs(PyObject* input, ::clif_proto::ProtoTypeInfo* output);
bool Clif_PyObjAs(PyObject* input, ::gtl::optional<::clif_proto::ProtoTypeInfo>* output);
PyObject* Clif_PyObjFrom(::clif_proto::ProtoTypeInfo*, py::PostConv);
PyObject* Clif_PyObjFrom(std::shared_ptr<::clif_proto::ProtoTypeInfo>, py::PostConv);
PyObject* Clif_PyObjFrom(std::unique_ptr<::clif_proto::ProtoTypeInfo>, py::PostConv);
PyObject* Clif_PyObjFrom(const ::clif_proto::ProtoTypeInfo&, py::PostConv);
// CLIF use `::clif_proto::ServiceInfo` as ServiceInfo
bool Clif_PyObjAs(PyObject* input, ::clif_proto::ServiceInfo** output);
bool Clif_PyObjAs(PyObject* input, std::shared_ptr<::clif_proto::ServiceInfo>* output);
bool Clif_PyObjAs(PyObject* input, std::unique_ptr<::clif_proto::ServiceInfo>* output);
bool Clif_PyObjAs(PyObject* input, ::clif_proto::ServiceInfo* output);
bool Clif_PyObjAs(PyObject* input, ::gtl::optional<::clif_proto::ServiceInfo>* output);
PyObject* Clif_PyObjFrom(::clif_proto::ServiceInfo*, py::PostConv);
PyObject* Clif_PyObjFrom(std::shared_ptr<::clif_proto::ServiceInfo>, py::PostConv);
PyObject* Clif_PyObjFrom(std::unique_ptr<::clif_proto::ServiceInfo>, py::PostConv);
PyObject* Clif_PyObjFrom(const ::clif_proto::ServiceInfo&, py::PostConv);

}  // namespace clif_proto

// CLIF init_module if (PyObject* m = PyImport_ImportModule("clif.python.utils.proto_util")) Py_DECREF(m);
// CLIF init_module else goto err;
